def kmp(P, T):
    # Вычисляем начальную позицию (количество символов) самого длинного суффикса, совпадающего с префиксом,
    # и сохраняем их в список K. Первый элемент K установлен в -1, второй - в 0.
    K = []  # K[t] хранит значение, на которое нужно сдвинуть шаблон P при несовпадении в позиции t
    t = -1  # Длина K равна len(P) + 1, первый элемент равен -1 (соответствует пустому префиксу)
    K.append(t)  # Добавляем первый элемент, сохраняем t = -1
    for k in range(1, len(P) + 1):
        # Обходим все элементы P, вычисляя соответствующие значения для каждого
        while (t >= 0 and P[t] != P[
            k - 1]):  # если t=-1, устанавливаем t=0; если t>=0 и суффикс не совпадает, пробуем более короткий суффикс
            t = K[t]
        t = t + 1  # Если совпадение найдено, увеличиваем позицию совпадения на 1
        K.append(t)  # Записываем позицию совпадения для k

    # Сопоставляем строку T с шаблоном P
    m = 0  # Текущая позиция совпадения в P при сравнении с T
    for i in range(0, len(T)):  # Последовательно обходим T
        while (m >= 0 and P[m] != T[
            i]):  # При несовпадении в позиции m сдвигаем P на K[m] позиций и перезапускаем сравнение
            m = K[m]
        m = m + 1  # Если позиция m совпадает, переходим к следующей позиции в P
        if m == len(
                P):  # Если достигнут конец P, найдено полное совпадение. Продолжаем сравнение со сдвигом P на K[m] позиций
            print(i - m + 1, i)
            m = K[m]


if __name__ == "__main__":
    kmp('abcbabca', 'abcbabcabcbabcbabcbabcabcbabcbabca')
    kmp('abab', 'ababcabababc')
